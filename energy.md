# EnergyInterface
Простой класс на Java
### 1. Что такое АДТ?
  
  АТД представляет собой тип данных, что означет следущее:
    наличие определенных доступных операций над элементами этого типа;
    данные, относительно которых эти операции выполняются (диапазон значений).
    
  
  Абстракция – это выделение и придание совокупности объектов общих свойств, которые определяют их концепутальные границы и отличают от всех других видов объектов. Иными словами, абстракция позволяет “пролить свет” на нужные нам данные объектов и, при этом, “затенить” те данные, которые нам не важны. (Гради Буч)
    
  
  АТД – это такой тип данных, который скрывает свою внутреннюю реализацию от клиентов. Удивительно то, что путем применения абстракции АТД позволяет нам не задумываться над низкоуровневыми деталями реализации, а работать с высокоуровневой сущностью реального мира (Стив Макконнелл).
    
### 2. Что такое предусловия?Для чего нужны? Что такое постусловия? Что такое класс? Что такое объект?
    
  ***Предусловие*** 
      
   Каждой из функций "требует" перечисляются условия, которым должны удовлетворять аргументы функции, чтобы входить в ее область; 
        Булевское выражение, которое определяет область функции, называется предусловием соответствующей частичной функции
        Нужно для введения коректных данных
        
  ***Постусловие*** 
    
  <sub>abstract RATIONAL mult [a,b]</sub>
  
  <sub>RATIONAL a,b;</sub>
  
  <sub>postcondition mult[0] = a[0]*b[0]</sub>
                 <sub>mult[1] = a[1]*b[1]</sub>
                    
   Постусловие указывает, что делает операция. В пост-условие, используется имя функции (в данном случае mult) для обозначения результата операции. Таким образом, mult [0] представляет числитель результата и множитель 1 представляет знаменатель результат. То есть указывает, какие условия становятся истинными после того, как выполняется операция. В этом примере пост-условие указывает что числитель результата рационального умножения равен целое произведение числителей двух входов и знаменателя равно целому произведению двух знаменателей.
      
  ***Класс***
  
  В объектно-ориентированном программировании (ООП) — класс это основной элемент, в рамках которого осуществляется конструирование программ. Класс содержит в себе данные и код, который управляет этими данными.


   Класс зачастую описывает объект реального мира. Как и реальный объект, класс содержит свой набор параметров и характеристик. Каждый такой параметр называется поле класса (очень похоже на обычные переменные). Также класс способен манипулировать своими характеристиками (полями) с помощью методов класса (похожи на функции в процедурных языках).
   
   
Следует понимать, что класс — это каркас, иначе говоря, описание реального объекта. На основе этого «описания» создаются экземпляры реального объекта. 

  ***Объект***
     
   Объекты — это сущности, у которых есть свойства и поведение. Обычно объекты являются экземплярами какого-нибудь класса. Например, в игре может быть класс Character (персонаж), а его экземплярами будут hero или npc.

### 3. Что такое абстрагирование?

Представьте, что водитель едет в автомобиле по оживлённому участку движения. Понятно, что в этот момент он не будет задумываться о химическом составе краски автомобиля, особенностях взаимодействия шестерён в коробке передач или влияния формы кузова на скорость (разве что, автомобиль стоит в глухой пробке и водителю абсолютно нечем заняться). Однако, руль, педали, указатель поворота (ну и, возможно, пепельницу) он будет использовать регулярно.


**Абстрагирование** – это способ выделить набор значимых характеристик объекта, исключая из рассмотрения незначимые. Соответственно, **абстракция** – это набор всех таких характеристик.

### 4. Что такое инкапсуляция? Что такое метод, конструктор, оператор?

Инкапсуляция – это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали
реализации от пользователя.

Инкапсуляция неразрывно связана с понятием интерфейса класса. По сути, всё то, что не входит в интерфейс, инкапсулируется в классе.

Инкапсуляция (от лат. in capsule — в оболочке) — это заключение данных и функционала в оболочку. В объектно-ориентированном программировании в роли оболочки выступают классы: они не только собирают переменные и методы в одном месте, но и защищают их от вмешательства извне (сокрытие).

Когда я думаю, как это выглядит в реальном мире, когда законы инкапсуляции нарушаются, в силу каких-то причин, почему-то очень живо представляется бабушка, сидящая на диванчике, а рядом с ней на тумбочке – её вставные челюсти, парик, очки и протез левой ноги у дивана. Жуткая картина.

А ещё представляется, как я прихожу в ресторан, заказываю утку под вишнёвым соусом, а повар с сияющей улыбкой прямо на моих глазах рубит ей голову, потрошит и кидает в кипяток. Тоже мало приятного.

В первом случае – хотелось бы какой-то целостности объекта, во втором – поменьше деталей о процессе.

Это и есть то, на чём базируются инкапсуляция и сокрытие данных. Детали реализации и данные упакованы в объект, и объект является их полноправным владельцем.

С одной стороны, мы избавляемся от необходимости вникать в детали, как что объект делает, с другой – так с его данными проще и безопаснее работать. **Проще** – потому что они все находятся прямо в самом объекте, **безопаснее** – потому что есть возможность установить правила доступа ко всем его данным и функционалу.

И вот это уже называется сокрытие данных (**data hiding**). 

Можно сказать, что сокрытие – это одна из задач инкапсуляции. Но само по себе сокрытие данных инкапсуляцией не является.

Также сказать, что инкапсуляция – это сокрытие данных, тоже было бы неверно. Потому что её задачи выходят за рамки сокрытия.

Если мы говорим, что данный метод инкапсулирует некий алгоритм, то подразумеваем, что в данном методе происходит определённое вычисление, детали которого нам знать необязательно, но результатам которого мы можем доверять и пользоваться ими.

Также мы можем сказать, что объект, в котором инкапсулированы данные, может скрывать их – то есть защищать от несанкционированного доступа.

### 5. Что такое принцип сокрытия? Что такое «чёрный ящик»?

Сокрытие данных достигается посредством модификаторов доступа (в С# – это модификаторы `private`, `public`, `protected`, `protected internal`), каждый из которых определяет свой уровень доступности членов типа.

Модификаторы доступа – это конкретные слова, определяющие тех, кому доступны или не доступны для использования данные.

Существует несколько основных модификаторов доступа:

`Public` – «публичный, доступный всем».
`Default` – «по умолчанию». Это значение по умолчанию, в ситуации отсутствия модификатора доступа. Сведения с данным словом доступны в пределах package (упаковка).
`Protected` – «защищенный». Имеет сходство с `default`, но отличается тем, что доступ есть и у классов наследников.
`Private` – «частный, личный». Эти сведения видны лишь самому классу.

#### Модификатор доступа `public`

Первый уровень, с которым сталкиваются все разработчики, — публичный. Чтобы сказать компилятору, что что-то должно быть доступно для всех, используется ключевое слово `public`.

Объявив экземпляр этого класса, можно обращаться к любым его полям в любом месте программы, где доступен сам объект (речь о локальных и глобальных переменных).

Это удобно, потому что можно в любой момент выполнить любое действие над объектом и его данными.

Это плохо по нескольким причинам:

* Если поле можно изменить в любом месте программы, сложно отслеживать ошибки, потому что не всегда понятно, где что-то пошло не так.
* Если вдруг в программу во время работы попадёт чужой код, он сможет изменять и читать любые поля любых объектов.

#### Модификатор доступа `private`

Чтобы поля были защищены от вмешательства, используется ключевое слово `private` — оно делает члены класса доступными только внутри самого класса.

Теперь эти поля нельзя будет изменить нигде, кроме как в методах этого класса. Но и получить их значение извне тоже не получится, а попытка вывести приведёт к ошибке

Есть два способа сделать поле доступным только для чтения. Первый — использовать ключевое слово `readonly`, но оно запрещает менять значение вообще.

Второй способ заключается в том, чтобы передавать значения приватного члена класса через публичный. Например, с помощью методов `set` и `get`

Ключевое слово `private` можно также применять и к методам. Это делает их доступными только внутри класса.

Также приватным можно сделать сам класс, если он находится внутри другого класса.

#### Черный ящик

![image](https://user-images.githubusercontent.com/83748388/203359863-00d9f1b3-640b-4bfb-8f80-a24a0cd2021d.png)

Как видите, сейчас мы не особо задумываемся о том, как программа устроена внутри. Нам важно только то, что программа получает на входе и какие данные выдаёт на выходе. Подобное представление о работе программы называется "модель чёрного ящика". Понятно, что данный подход можно применять не только в программировании.

### 6. Что такое поле класса? Что такое свойство (C#)?

#### Поле класса
*Поле класса* в ООП мире называется переменная, связанная с классом или объектом. Все данные объекта хранятся в его полях. Доступ к полям осуществляется по их имени. У полей есть альтернативные названия:

* атрибут класса
* переменная-член класса

Поля бывают собственные (обычные) и общие для всех объектов (экземпляров (instance’ов)) класса (статические).

#### Свойство класса
*Свойство* — это способ доступа к внутреннему состоянию объекта, имитирующий поле. Обращение к свойству объекта выглядит так же, как и обращение к полю, но, в действительности, реализовано через вызов функции. При попытке задать значение свойства вызывается метод называемый сеттером (setter). А при попытке получить значение свойства — геттер (getter).

Как правило, свойство связано с некоторым внутренним полем объекта. Но свойству вообще может не быть сопоставлена ни одна переменная объекта, хотя пользователь данного объекта имеет дело с ним так, как если бы это было настоящее поле.

Свойства повышают гибкость и безопасность программирования, поскольку, являясь частью публичного интерфейса и позволяют менять внутреннюю реализацию объекта без изменения его свойств.

Свойства облегчают модификацию кода в случаях, когда класс изначально был реализован с нарушением инкапсуляции, а в дальнейшем потребовалось изменить способ доступа к полю.

### 7. Как вызвать метод конкретного объекта находящегося в массиве? Чем отличаются обращения к методам в С++ с использованием объекта, ссылки на объект и указателя на объект?
### 8. Что такое равенство объектов? Когда объекты идентичны?

Если мы посмотрим на другие языки программирования, наиболее логичным выводом о том, как сравнивать значения, может быть оператор `==` и его антагонист `!=`.

Да, мы можем использовать их для проверки равенства, и они сравнивают значения друг с другом, но это может быть не то значение, которое вы ожидаете.

*Примитивы* - это литералы, фиксированные значения в памяти, которые можно проверить на равенство с `==`.

За исключением тех случаев, когда они не могут.

В отличие от других примитивных типов данных, типы данных с плавающей запятой `float` и `double` нельзя надежно проверить на равенство с `==` из-за их метода хранения в памяти. Это не точные значения:

```java
float value = 1.0f;
value += 0.1f;      // 1.1f
value += 0.1f;      // 1.2f
value += 0.1f;      // 1.3000001f
boolean isEqual = (value == 1.3f) // false
```
У нас есть два варианта справиться с этим. Либо с помощью `java.util.BigDecimal`, что точно. Или используя сравнения на основе пороговых значений:

```java
float value = 1.0f;
value += 0.1f;      // 1.1f
value += 0.1f;      // 1.2f
value += 0.1f;      // 1.3000001f
float THRESHOLD = 0.00001f;
boolean isEqual = Math.abs(value - 1.3f) < THRESHOLD); // true
```

*Массивы*
Еще одна ловушка - это примитивные массивы, потому что массивы не являются примитивным типом, это объекты.

*Объекты*
Если вы сравните объекты с `==`, он также сравнит значение объекта. Единственная проблема здесь в том, что значение объекта на самом деле является его ссылкой, отсюда и название ссылочный тип объекта.

Это означает, что два значения равны, только если они указывают на один и тот же объект в памяти.

На практике в одних случаях переменные могут быть равны, в других - нет:

```java
String a = "a";
String b = "b";
String ab = "ab";
boolean result1 = (a == "a");      // true
boolean result2 = (ab == "ab");    // true
boolean result3 = (a + b == "ab"); // false
```

Компилятор и JVM могут оптимизировать строковые константы, поэтому `result2` равно `true`. И `result3` это `false`, потому что `a + b` создает новый объект в памяти. Все это может зависеть от реализации и различаться для разных JVM.

Еще одна «не столь очевидная» ошибка может случиться с примитивными типами-оболочками:

```java
Integer a = 127;
Integer b = 127;
Integer c = 128;
Integer d = 128;
boolean equal      = (a == b); // true
boolean notEqual   = (c == d); // false
boolean equalAgain = (new Integer(128) == 128); // true
```


`valueOf(...)` методы `java.util.Integer` и `java.util.Long` фактически кэшируют значения для определенных диапазонов (от -128 до 127), делая `a` и `b` одним и тем же объектом, но не `c` и `d`. А благодаря распаковке `equalAgain` это `true`.

#### `Object.equals` (Другой объект) и `Object hashCode ()`
Класс `java.lang.Object` предоставляет метод `equals` для всех своих подклассов с довольно простой реализацией:

```java
public boolean equals(Object obj) {
    return (this == obj);
}
```
По умолчанию каждый из наших типов наследует проблемное сравнение объектных ссылок. Чтобы иметь возможность использовать equals для фактического равенства, нам нужно переопределить его в наших типах, имея определенные свойства:

*Рефлексивно: объект должен быть равен самому себе: `obj.equals(obj) == true`
*Симметричный: если `a.equals(b) == true`, то `b.equals(a)` также должен быть `true`.
*Переходный: если `a.equals(b) == true` и `b.equals(c) == true`, тогда `a.equals(c)` должно быть `true`.
*Согласовано: `a.equals(b)` всегда должно иметь одно и то же значение для неизмененных объектов.
*Обработка нулей: `a.equals(null)` должно быть `false`.
*Хеш-код: одинаковые объекты должны иметь одинаковый хеш-код.

Если мы предоставляем наш собственный `equals` метод, нам также необходимо переопределить `hashCode`.

Есть несколько простых правил, которым мы должны следовать, чтобы не получить неверных результатов при сравнении значений на равенство или их естественный порядок.

* Никогда не сравнивайте объекты с `==`
Это работает, только если это один и тот же объект. Различные объекты с одинаковым значением не равны. Всегда используйте `boolean equals(Object other)` для сравнения на равенство.

* Всегда применяйте `equals` и `hashCode if needed`
Чтобы сделать тип проверяемым на равенство, нам необходимо реализовать как `equals` , так и `hashCode`, чтобы гарантировать правильное и последовательное поведение.

* Типы данных с плавающей запятой неточны
Всегда помните, что типы данных с плавающей запятой неточны и их сложнее сравнивать.

Если нам нужно работать с десятичными значениями и нужна абсолютная точность, мы всегда должны использовать `java.util.BigDecimal`. Но имейте в виду, что его `equals` основан на его точности:

```java
BigDecimal a = new BigDecimal("2.0");
BigDecimal b = new BigDecimal("2.0");
BigDecimal c = new BigDecimal("2.00");
boolean equal    = a.equals(b); // true
boolean notEqual = a.equals(c); // false
```

Если нам нужно более простое сравнение, мы можем использовать `compareTo`:

```java
BigDecimal a = new BigDecimal("2.0");
BigDecimal b = new BigDecimal("2.0");
BigDecimal c = new BigDecimal("2.00");
boolean equal = a.equals(b);    // true
int result    = a.compareTo(c); // 0
```

`BigDecimal` API не очень хорош по сравнению с примитивными операциями, в первую очередь из-за его неизменности. Но на самом деле это хорошо, ведь правильность важнее красоты.

**Помните об автобоксе / распаковке**
Поскольку компилятор делает это за кулисами, мы должны обязательно сравнивать примитивы или объекты-оболочки благодаря _111 _ / _ 112_ кэшированию.

Чтобы быть на 100% уверенным, мы могли бы использовать вместо этого `Comparable<T>#compareTo(T)` типов оболочки, которая всегда использует инкапсулированное значение, а не ссылку на объект.

### 9. Что такое поведение? Что такое состояние?

**Поведение объекта (behavior)** - перечень (обычно статический) методов объекта и результатов их вызова (зависят от текущего состояния).

Мы оговариваем, что перечень методов, обычно статический, так как в некоторых языках программирования существуют механизмы, позволяющие изменять перечень методов класса или отдельного объекта при выполнении программы.

Мы оговариваем, что результаты вызова методов зависят от текущего состояния или, по-другому, определяются историей объекта (то есть историей изменения его состояния), так как один и тот же метод в общем случае может возвращать разные результаты в зависимости от состояния.

В предыдущих главах мы уже показывали, что методы имеют доступ ко всем полям объекта независимо от уровня видимости. При этом доступ выполняется через неявно передаваемую в метод переменную `this`, указывающую на объект, для которого был вызван метод. Если локальная переменная метода имеет такое же имя, как и некоторое поле класса, то эта локальная переменная скрывает (hide) поле класса. 

**Состояние объекта (state)** – перечень полей объекта (обычно статический) и текущих значений каждого из этих полей (обычно динамический).

Мы оговариваем, что перечень полей обычно статический, то есть зафиксированный в определении класса, так как в некоторых языках перечень полей может быть изменен после создания объекта.

Мы оговариваем, что перечень текущих значений полей обычно динамический, то есть может меняться после создания объекта, так как во всех языках есть механизмы, позволяющие ограничить изменение полей после создания объекта. Мы обсудим некоторые из таких возможностей в следующем параграфе.

В настоящей книге мы используем термин поле (`field`), так как оно используется в C#. При этом в других языках программирования для обозначения полей класса могут применяться и другие термины: переменная-член (`member variable`, `member`), свойство (`property`).
